<?xml version="1.0"?>
<doc>
    <assembly>
        <name>stellar</name>
    </assembly>
    <members>
        <member name="M:stellar.Controllers.installController.is_installed">
            <summary>
            This checks the config file for the state of installation.  We are reading from the web.config
            to insure that we are going about this the fastest way possible since the config is loaded and 
            cached.  Also when changed, it restarts the app.
            </summary>
            <returns></returns>
        </member>
        <member name="M:stellar.Controllers.installController.set_installed_state(System.String)">
            <summary>
            This is what changes the web.config.  After which the app restarts and the install state is True/False
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:stellar.Controllers.installController.load_from_content_xml">
            <summary>
            what should happen is load file choose mode, loop thru model properties and check for them
            If found in the xml then apply to the new object created. save objects
            </summary>
        </member>
        <member name="M:stellar.Controllers.installController.load_from_xml(System.String,stellar.Models.site)">
            <summary>
            This it the
            </summary>
            <param name="type"></param>
            <param name="site"></param>
        </member>
        <member name="M:stellar.Controllers.installController.xml_to_object(System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement},stellar.Models.site)">
            <summary>
            we are going to make and fill objects the best we can by first taking the roor 
            element and looking at it's child nodes and it's attributes.  An node will repersent a 
            list to match AR in the sense that it's a HasMany or HasManyBelongsTo.  All attributes
            are the other flat properties of the object.
            
            Note: The root element name is the object name.
            </summary>
            <param name="elements"></param>
            <param name="site"></param>
        </member>
        <member name="P:stellar.Models._base.taxonomies">
            
        </member>
        <member name="M:stellar.Models.publish_base.get_published">
            <summary>
            Travel up to the parent post (working post) as a percaution then get the children and find the newest published version
            </summary>
            <returns></returns>
        </member>
        <member name="T:stellar.oauth.Code.Client">
            <summary>
            An OAuth 2.0 Client that has registered with this Authorization Server.
            </summary>
        </member>
        <member name="M:stellar.oauth.Code.Client.DotNetOpenAuth#OAuth2#IClientDescription#IsCallbackAllowed(System.Uri)">
            <summary>
            Determines whether a callback URI included in a client's authorization request
            is among those allowed callbacks for the registered client.
            </summary>
            <param name="callback">The absolute URI the client has requested the authorization result be received at.</param>
            <returns>
              <c>true</c> if the callback URL is allowable for this client; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:stellar.oauth.Code.Client.DotNetOpenAuth#OAuth2#IClientDescription#IsValidClientSecret(System.String)">
            <summary>
            Checks whether the specified client secret is correct.
            </summary>
            <param name="secret">The secret obtained from the client.</param>
            <returns><c>true</c> if the secret matches the one in the authorization server's record for the client; <c>false</c> otherwise.</returns>
            <remarks>
            All string equality checks, whether checking secrets or their hashes,
            should be done using <see cref="M:DotNetOpenAuth.Messaging.MessagingUtilities.EqualsConstantTime(System.String,System.String)"/> to mitigate timing attacks.
            </remarks>
        </member>
        <member name="P:stellar.oauth.Code.Client.DotNetOpenAuth#OAuth2#IClientDescription#DefaultCallback">
            <summary>
            Gets the callback to use when an individual authorization request
            does not include an explicit callback URI.
            </summary>
            <value>
            An absolute URL; or <c>null</c> if none is registered.
            </value>
        </member>
        <member name="P:stellar.oauth.Code.Client.DotNetOpenAuth#OAuth2#IClientDescription#ClientType">
            <summary>
            Gets the type of the client.
            </summary>
        </member>
        <member name="P:stellar.oauth.Code.Client.DotNetOpenAuth#OAuth2#IClientDescription#HasNonEmptySecret">
            <summary>
            Gets a value indicating whether a non-empty secret is registered for this client.
            </summary>
        </member>
        <member name="T:stellar.oauth.Code.DatabaseKeyNonceStore">
            <summary>
            A database-persisted nonce store.
            </summary>
        </member>
        <member name="M:stellar.oauth.Code.DatabaseKeyNonceStore.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:stellar.oauth.Code.DatabaseKeyNonceStore"/> class.
            </summary>
        </member>
        <member name="M:stellar.oauth.Code.DatabaseKeyNonceStore.StoreNonce(System.String,System.String,System.DateTime)">
            <summary>
            Stores a given nonce and timestamp.
            </summary>
            <param name="context">The context, or namespace, within which the
            <paramref name="nonce"/> must be unique.
            The context SHOULD be treated as case-sensitive.
            The value will never be <c>null</c> but may be the empty string.</param>
            <param name="nonce">A series of random characters.</param>
            <param name="timestampUtc">The UTC timestamp that together with the nonce string make it unique
            within the given <paramref name="context"/>.
            The timestamp may also be used by the data store to clear out old nonces.</param>
            <returns>
            True if the context+nonce+timestamp (combination) was not previously in the database.
            False if the nonce was stored previously with the same timestamp and context.
            </returns>
            <remarks>
            The nonce must be stored for no less than the maximum time window a message may
            be processed within before being discarded as an expired message.
            This maximum message age can be looked up via the
            <see cref="P:DotNetOpenAuth.Configuration.MessagingElement.MaximumMessageLifetime"/>
            property, accessible via the <see cref="!:DotNetOpenAuth.Configuration.DotNetOpenAuthSection.Configuration"/>
            property.
            </remarks>
        </member>
        <member name="T:stellar.oauth.Code.HttpHeaderAttribute">
            <summary>
            Represents an attribute that is used to add HTTP Headers to a Controller Action response.
            </summary>
        </member>
        <member name="M:stellar.oauth.Code.HttpHeaderAttribute.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:stellar.oauth.Code.HttpHeaderAttribute"/> class.
            </summary>
            <param name="name">The HTTP header name.</param>
            <param name="value">The HTTP header value.</param>
        </member>
        <member name="M:stellar.oauth.Code.HttpHeaderAttribute.OnResultExecuted(System.Web.Mvc.ResultExecutedContext)">
            <summary>
            Called by the MVC framework after the action result executes.
            </summary>
            <param name="filterContext">The filter context.</param>
        </member>
        <member name="P:stellar.oauth.Code.HttpHeaderAttribute.Name">
            <summary>
            Gets or sets the name of the HTTP Header.
            </summary>
        </member>
        <member name="P:stellar.oauth.Code.HttpHeaderAttribute.Value">
            <summary>
            Gets or sets the value of the HTTP Header.
            </summary>
        </member>
        <member name="M:stellar.oauth.Code.OAuth2AuthorizationServer.CreateAuthorizationServerSigningKey">
            <summary>
            Creates the RSA key used by all the crypto service provider instances we create.
            </summary>
            <returns>RSA data that includes the private key.</returns>
        </member>
        <member name="M:stellar.oauth.Code.Utilities.AsUtc(System.DateTime)">
            <summary>
            Ensures that local times are converted to UTC times.  Unspecified kinds are recast to UTC with no conversion.
            </summary>
            <param name="value">The date-time to convert.</param>
            <returns>The date-time in UTC time.</returns>
        </member>
        <member name="F:stellar.Authorize.form1">
            <summary>
            form1 control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.multiView">
            <summary>
            multiView control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.OAuth10ConsumerWarning">
            <summary>
            OAuth10ConsumerWarning control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.consumerLabel">
            <summary>
            consumerLabel control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.desiredAccessLabel">
            <summary>
            desiredAccessLabel control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.btnAuthorize">
            <summary>
            btnAuthorize control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.OAuthAuthorizationSecToken">
            <summary>
            OAuthAuthorizationSecToken control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.View1">
            <summary>
            View1 control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.verifierMultiView">
            <summary>
            verifierMultiView control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.View2">
            <summary>
            View2 control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.verificationCodeLabel">
            <summary>
            verificationCodeLabel control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="F:stellar.Authorize.View3">
            <summary>
            View3 control.
            </summary>
            <remarks>
            Auto-generated field.
            To modify move field declaration from designer file to code-behind file.
            </remarks>
        </member>
        <member name="M:stellar.Controllers.mediaController.New">
            
        </member>
        <member name="M:stellar.Controllers.mediaController.removeImage(System.Int32,System.Int32,System.Boolean)">
            
        </member>
        <member name="P:stellar.GlobalApplication.DataContext">
            <summary>
            Gets the transaction-protected database connection for the current request.
            </summary>
        </member>
        <member name="T:cms.utils.Diff">
            <summary>
            This Class implements the Difference Algorithm published in
            "An O(ND) Difference Algorithm and its Variations" by Eugene Myers
            Algorithmica Vol. 1 No. 2, 1986, p 251.  
            
            There are many C, Java, Lisp implementations public available but they all seem to come
            from the same source (diffutils) that is under the (unfree) GNU public License
            and cannot be reused as a sourcecode for a commercial application.
            There are very old C implementations that use other (worse) algorithms.
            Microsoft also published sourcecode of a diff-tool (windiff) that uses some tree data.
            Also, a direct transfer from a C source to C# is not easy because there is a lot of pointer
            arithmetic in the typical C solutions and i need a managed solution.
            These are the reasons why I implemented the original published algorithm from the scratch and
            make it avaliable without the GNU license limitations.
            I do not need a high performance diff tool because it is used only sometimes.
            I will do some performace tweaking when needed.
            
            The algorithm itself is comparing 2 arrays of numbers so when comparing 2 text documents
            each line is converted into a (hash) number. See DiffText(). 
            
            Some chages to the original algorithm:
            The original algorithm was described using a recursive approach and comparing zero indexed arrays.
            Extracting sub-arrays and rejoining them is very performance and memory intensive so the same
            (readonly) data arrays are passed arround together with their lower and upper bounds.
            This circumstance makes the LCS and SMS functions more complicate.
            I added some code to the LCS function to get a fast response on sub-arrays that are identical,
            completely deleted or inserted.
            
            The result from a comparisation is stored in 2 arrays that flag for modified (deleted or inserted)
            lines in the 2 data arrays. These bits are then analysed to produce a array of Item objects.
            
            Further possible optimizations:
            (first rule: don't do it; second: don't do it yet)
            The arrays DataA and DataB are passed as parameters, but are never changed after the creation
            so they can be members of the class to avoid the paramter overhead.
            In SMS is a lot of boundary arithmetic in the for-D and for-k loops that can be done by increment
            and decrement of local variables.
            The DownVector and UpVector arrays are alywas created and destroyed each time the SMS gets called.
            It is possible to reuse tehm when transfering them to members of the class.
            See TODO: hints.
            
            diff.cs: A port of the algorythm to C#
            Copyright (c) by Matthias Hertel, http://www.mathertel.de
            This work is licensed under a BSD style license. See http://www.mathertel.de/License.aspx
            
            Changes:
            2002.09.20 There was a "hang" in some situations.
            Now I undestand a little bit more of the SMS algorithm. 
            There have been overlapping boxes; that where analyzed partial differently.
            One return-point is enough.
            A assertion was added in CreateDiffs when in debug-mode, that counts the number of equal (no modified) lines in both arrays.
            They must be identical.
            
            2003.02.07 Out of bounds error in the Up/Down vector arrays in some situations.
            The two vetors are now accessed using different offsets that are adjusted using the start k-Line. 
            A test case is added. 
            
            2006.03.05 Some documentation and a direct Diff entry point.
            
            2006.03.08 Refactored the API to static methods on the Diff class to make usage simpler.
            2006.03.10 using the standard Debug class for self-test now.
                       compile with: csc /target:exe /out:diffTest.exe /d:DEBUG /d:TRACE /d:SELFTEST Diff.cs
            2007.01.06 license agreement changed to a BSD style license.
            2007.06.03 added the Optimize method.
            2007.09.23 UpVector and DownVector optimization by Jan Stoklasa ().
            2008.05.31 Adjusted the testing code that failed because of the Optimize method (not a bug in the diff algorithm).
            2008.10.08 Fixing a test case and adding a new test case.
            </summary>
        </member>
        <member name="M:cms.utils.Diff.DiffText(System.String,System.String)">
            <summary>
            Find the difference in 2 texts, comparing by textlines.
            </summary>
            <param name="TextA">A-version of the text (usualy the old one)</param>
            <param name="TextB">B-version of the text (usualy the new one)</param>
            <returns>Returns a array of Items that describe the differences.</returns>
        </member>
        <member name="M:cms.utils.Diff.DiffText(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Find the difference in 2 text documents, comparing by textlines.
            The algorithm itself is comparing 2 arrays of numbers so when comparing 2 text documents
            each line is converted into a (hash) number. This hash-value is computed by storing all
            textlines into a common hashtable so i can find dublicates in there, and generating a 
            new number each time a new textline is inserted.
            </summary>
            <param name="TextA">A-version of the text (usualy the old one)</param>
            <param name="TextB">B-version of the text (usualy the new one)</param>
            <param name="trimSpace">When set to true, all leading and trailing whitespace characters are stripped out before the comparation is done.</param>
            <param name="ignoreSpace">When set to true, all whitespace characters are converted to a single space character before the comparation is done.</param>
            <param name="ignoreCase">When set to true, all characters are converted to their lowercase equivivalence before the comparation is done.</param>
            <returns>Returns a array of Items that describe the differences.</returns>
        </member>
        <member name="M:cms.utils.Diff.Optimize(cms.utils.DiffData)">
            <summary>
            If a sequence of modified lines starts with a line that contains the same content
            as the line that appends the changes, the difference sequence is modified so that the
            appended line and not the starting line is marked as modified.
            This leads to more readable diff sequences when comparing text files.
            </summary>
            <param name="Data">A Diff data buffer containing the identified changes.</param>
        </member>
        <member name="M:cms.utils.Diff.DiffInt(System.Int32[],System.Int32[])">
            <summary>
            Find the difference in 2 arrays of integers.
            </summary>
            <param name="ArrayA">A-version of the numbers (usualy the old one)</param>
            <param name="ArrayB">B-version of the numbers (usualy the new one)</param>
            <returns>Returns a array of Items that describe the differences.</returns>
        </member>
        <member name="M:cms.utils.Diff.DiffCodes(System.String,System.Collections.Hashtable,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            This function converts all textlines of the text into unique numbers for every unique textline
            so further work can work only with simple numbers.
            </summary>
            <param name="aText">the input text</param>
            <param name="h">This extern initialized hashtable is used for storing all ever used textlines.</param>
            <param name="trimSpace">ignore leading and trailing space characters</param>
            <returns>a array of integers.</returns>
        </member>
        <member name="M:cms.utils.Diff.SMS(cms.utils.DiffData,System.Int32,System.Int32,cms.utils.DiffData,System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            This is the algorithm to find the Shortest Middle Snake (SMS).
            </summary>
            <param name="DataA">sequence A</param>
            <param name="LowerA">lower bound of the actual range in DataA</param>
            <param name="UpperA">upper bound of the actual range in DataA (exclusive)</param>
            <param name="DataB">sequence B</param>
            <param name="LowerB">lower bound of the actual range in DataB</param>
            <param name="UpperB">upper bound of the actual range in DataB (exclusive)</param>
            <param name="DownVector">a vector for the (0,0) to (x,y) search. Passed as a parameter for speed reasons.</param>
            <param name="UpVector">a vector for the (u,v) to (N,M) search. Passed as a parameter for speed reasons.</param>
            <returns>a MiddleSnakeData record containing x,y and u,v</returns>
        </member>
        <member name="M:cms.utils.Diff.LCS(cms.utils.DiffData,System.Int32,System.Int32,cms.utils.DiffData,System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            This is the divide-and-conquer implementation of the longes common-subsequence (LCS) 
            algorithm.
            The published algorithm passes recursively parts of the A and B sequences.
            To avoid copying these arrays the lower and upper bounds are passed while the sequences stay constant.
            </summary>
            <param name="DataA">sequence A</param>
            <param name="LowerA">lower bound of the actual range in DataA</param>
            <param name="UpperA">upper bound of the actual range in DataA (exclusive)</param>
            <param name="DataB">sequence B</param>
            <param name="LowerB">lower bound of the actual range in DataB</param>
            <param name="UpperB">upper bound of the actual range in DataB (exclusive)</param>
            <param name="DownVector">a vector for the (0,0) to (x,y) search. Passed as a parameter for speed reasons.</param>
            <param name="UpVector">a vector for the (u,v) to (N,M) search. Passed as a parameter for speed reasons.</param>
        </member>
        <member name="M:cms.utils.Diff.CreateDiffs(cms.utils.DiffData,cms.utils.DiffData)">
            <summary>Scan the tables of which lines are inserted and deleted,
            producing an edit script in forward order.  
            </summary>
            dynamic array
        </member>
        <member name="T:cms.utils.Diff.Item">
            <summary>details of one difference.</summary>
        </member>
        <member name="F:cms.utils.Diff.Item.StartA">
            <summary>Start Line number in Data A.</summary>
        </member>
        <member name="F:cms.utils.Diff.Item.StartB">
            <summary>Start Line number in Data B.</summary>
        </member>
        <member name="F:cms.utils.Diff.Item.deletedA">
            <summary>Number of changes in Data A.</summary>
        </member>
        <member name="F:cms.utils.Diff.Item.insertedB">
            <summary>Number of changes in Data B.</summary>
        </member>
        <member name="T:cms.utils.Diff.SMSRD">
            <summary>
            Shortest Middle Snake Return Data
            </summary>
        </member>
        <member name="T:cms.utils.DiffData">
            <summary>Data on one input file being compared.  
            </summary>
        </member>
        <member name="F:cms.utils.DiffData.Length">
            <summary>Number of elements (lines).</summary>
        </member>
        <member name="F:cms.utils.DiffData.data">
            <summary>Buffer of numbers that will be compared.</summary>
        </member>
        <member name="F:cms.utils.DiffData.modified">
            <summary>
            Array of booleans that flag for modified data.
            This is the result of the diff.
            This means deletedA in the first Data or inserted in the second Data.
            </summary>
        </member>
        <member name="M:cms.utils.DiffData.#ctor(System.Int32[])">
            <summary>
            Initialize the Diff-Data buffer.
            </summary>
            <param name="data">reference to the buffer</param>
        </member>
        <member name="T:stellar.IService1">
            <summary>
            This class is the interface for the exposed OAuth API.
            </summary>
        </member>
        <member name="M:stellar.Service1.GetAccounts">
            <summary>
            This service returns some data in JSON protected by OAuth.
            </summary>
            <returns></returns>
        </member>
        <member name="T:stellar.Code.CustomOAuthMessageFactory">
            <summary>
            A custom class that will cause the OAuth library to use our custom message types
            where we have them.
            </summary>
        </member>
        <member name="M:stellar.Code.CustomOAuthMessageFactory.#ctor(DotNetOpenAuth.OAuth.ChannelElements.IServiceProviderTokenManager)">
            <summary>
            Initializes a new instance of the <see cref="T:stellar.Code.CustomOAuthMessageFactory"/> class.
            </summary>
            <param name="tokenManager">The token manager instance to use.</param>
        </member>
        <member name="M:stellar.Tools.DatabaseNonceStore.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:stellar.Tools.DatabaseNonceStore"/> class.
            </summary>
        </member>
        <member name="M:stellar.Tools.DatabaseNonceStore.StoreNonce(System.String,System.String,System.DateTime)">
            <summary>
            Stores a given nonce and timestamp.
            </summary>
            <param name="context">The context, or namespace, within which the
            <paramref name="nonce"/> must be unique.
            The context SHOULD be treated as case-sensitive.
            The value will never be <c>null</c> but may be the empty string.</param>
            <param name="nonce">A series of random characters.</param>
            <param name="timestampUtc">The UTC timestamp that together with the nonce string make it unique
            within the given <paramref name="context"/>.
            The timestamp may also be used by the data store to clear out old nonces.</param>
            <returns>
            True if the context+nonce+timestamp (combination) was not previously in the database.
            False if the nonce was stored previously with the same timestamp and context.
            </returns>
            <remarks>
            The nonce must be stored for no less than the maximum time window a message may
            be processed within before being discarded as an expired message.
            This maximum message age can be looked up via the
            <see cref="P:DotNetOpenAuth.Configuration.MessagingElement.MaximumMessageLifetime"/>
            property, accessible via the <see cref="!:DotNetOpenAuth.Configuration.DotNetOpenAuthSection.Configuration"/>
            property.
            </remarks>
        </member>
        <member name="M:stellar.Code.DatabaseTokenManager.IsRequestTokenAuthorized(System.String)">
            <summary>
            Checks whether a given request token has already been authorized
            by some user for use by the Consumer that requested it.
            </summary>
            <param name="requestToken">The Consumer's request token.</param>
            <returns>
            True if the request token has already been fully authorized by the user
            who owns the relevant protected resources.  False if the token has not yet
            been authorized, has expired or does not exist.
            </returns>
        </member>
        <member name="M:stellar.Code.DatabaseTokenManager.GetTokenType(System.String)">
            <summary>
            Classifies a token as a request token or an access token.
            </summary>
            <param name="token">The token to classify.</param>
            <returns>Request or Access token, or invalid if the token is not recognized.</returns>
        </member>
        <member name="T:stellar.Code.OAuthAuthorizationManager">
            <summary>
            A WCF extension to authenticate incoming messages using OAuth.
            </summary>
        </member>
        <member name="M:stellar.Code.OAuthAuthorizationManager.CheckAccessCore(System.ServiceModel.OperationContext)">
            <summary>
            This method authorizes the OAuth request. The token is extracted from the header and the scope is checked.
            For the demonstration pourposes the scope is the URL of the service. In real world applications the scope would be the functional entity being accessed (eg. the calendar, the fotos etc...).
            </summary>
            <param name="operationContext"></param>
            <returns></returns>
        </member>
        <member name="M:stellar.Code.OAuthPrincipalAuthorizationPolicy.#ctor(DotNetOpenAuth.OAuth.ChannelElements.OAuthPrincipal)">
            <summary>
            Initializes a new instance of the <see cref="T:stellar.Code.OAuthPrincipalAuthorizationPolicy"/> class.
            </summary>
            <param name="principal">The principal.</param>
        </member>
        <member name="P:stellar.Code.OAuthPrincipalAuthorizationPolicy.Id">
            <summary>
            Gets a unique ID for this instance.
            </summary>
        </member>
        <member name="M:stellar.Tools.RequestScopedTokenMessage.#ctor(DotNetOpenAuth.Messaging.MessageReceivingEndpoint,System.Version)">
            <summary>
            Initializes a new instance of the <see cref="T:stellar.Tools.RequestScopedTokenMessage"/> class.
            </summary>
            <param name="endpoint">The endpoint that will receive the message.</param>
            <param name="version">The OAuth version.</param>
        </member>
        <member name="P:stellar.Tools.RequestScopedTokenMessage.Scope">
            <summary>
            Gets or sets the scope of the access being requested.
            </summary>
        </member>
        <member name="F:stellar.Code.TokenAuthorizationState.UnauthorizedRequestToken">
            <summary>
            An unauthorized request token.
            </summary>
        </member>
        <member name="F:stellar.Code.TokenAuthorizationState.AuthorizedRequestToken">
            <summary>
            An authorized request token.
            </summary>
        </member>
        <member name="F:stellar.Code.TokenAuthorizationState.AccessToken">
            <summary>
            An authorized access token.
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DTOBase.name">
            <summary>
             Name of file/dir. Required
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DTOBase.hash">
            <summary>
             Hash of current file/dir path, first symbol must be letter, symbols before _underline_ - volume id, Required.
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DTOBase.post">
            <summary>
             Posting json object.
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DTOBase.mime">
            <summary>
             mime type. Required.
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DTOBase.ts">
            <summary>
            file modification time in unix timestamp. Required.
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DTOBase.size">
            <summary>
             file size in bytes
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DTOBase.read">
            <summary>
             is readable
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DTOBase.write">
            <summary>
            is writable
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DTOBase.locked">
            <summary>
             is file locked. If locked that object cannot be deleted and renamed
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DirectoryDTO.phash">
            <summary>
             Hash of parent directory. Required except roots dirs.
            </summary>
        </member>
        <member name="P:ElFinder.DTO.DirectoryDTO.dirs">
            <summary>
            Is directory contains subfolders
            </summary>
        </member>
        <member name="P:ElFinder.DTO.FileDTO.phash">
            <summary>
             Hash of parent directory. Required except roots dirs.
            </summary>
        </member>
        <member name="T:ElFinder.Connector">
            <summary>
            Represents a connector which process elFinder request
            </summary>
        </member>
        <member name="M:ElFinder.Connector.#ctor(ElFinder.IDriver)">
            <summary>
            Initialize new instance of ElFinder.Connector
            </summary>
            <param name="driver">Driver to process request</param>
        </member>
        <member name="M:ElFinder.Connector.Process(System.Web.HttpRequestBase)">
            <summary>
            Process elFinder request
            </summary>
            <param name="request">Request from elFinder</param>
            <returns>Json response, which must be sent to elfinder</returns>
        </member>
        <member name="M:ElFinder.Connector.Process(System.Web.HttpRequestBase,System.Collections.Hashtable)">
            <summary>
            Process elFinder request
            </summary>
            <param name="request">Request from elFinder</param>
            <returns>Json response, which must be sent to elfinder</returns>
        </member>
        <member name="T:ElFinder.FileSystemDriver">
            <summary>
            Represents a driver for local file system
            </summary>
        </member>
        <member name="M:ElFinder.FileSystemDriver.#ctor">
            <summary>
            Initialize new instance of class ElFinder.FileSystemDriver 
            </summary>
        </member>
        <member name="M:ElFinder.FileSystemDriver.AddRoot(ElFinder.Root)">
            <summary>
            Adds an object to the end of the roots.
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:ElFinder.FileSystemDriver.Roots">
            <summary>
            Gets collection of roots
            </summary>
        </member>
        <member name="T:ElFinder.Root">
            <summary>
            Represents a root of file system
            </summary>
        </member>
        <member name="M:ElFinder.Root.#ctor(System.IO.DirectoryInfo,System.String)">
            <summary>
            Initialize new instanse of class ElFinder.Root
            </summary>
            <param name="directory">Directory which will be root</param>
            <param name="url">Url to root</param>
        </member>
        <member name="M:ElFinder.Root.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Initialize new instanse of class ElFinder.Root
            </summary>
            <param name="directory">Directory which will be root</param>
        </member>
        <member name="P:ElFinder.Root.Alias">
            <summary>
            Get or sets root alias
            </summary>
        </member>
        <member name="T:stellar.Services.file_handler">
            <summary>
            /* all file must match this pattern
            *    /foo/bar.html
            *  or
            *    C://root/foo/bar.html
            * Everything is front facing paths
            * 
            * This is the base for 
            * • Capturing 
            * • Managing 
            * • Storing  
            * • Preserving  
            * • Delivering
            * 
            * ALL diles coming must be paths.  FileInfo objects will be made here.
            * 
            */
            </summary>
        </member>
        <member name="M:stellar.Services.file_handler.normalize_path(System.String)">
            <summary>
            Change all directory separators to face the same way
            </summary>
            <param name="file">file path given</param>
            <returns>the normalized file path</returns>
        </member>
        <member name="M:stellar.Services.file_handler.relative_file_path(System.String)">
            <summary>
            Function to take any manor of path and resolve it and retrun the coreected path
            </summary>
            <param name="filepath">File path to be checked</param>
            <returns>String - Return the tested string if found</returns>
            
        </member>
        <member name="M:stellar.Services.file_handler.true_file_path(System.String)">
            <summary>
            Function to take any manor of path and resolve it and retrun the coreected path.
            We don't care if it exist or not, we just one to normalize it.
            </summary>
            <param name="filepath">File path to be checked</param>
            <returns>String - Return the tested string if found</returns>
        </member>
        <member name="M:stellar.Services.file_handler.true_file_path(System.String,System.Boolean)">
            <summary>
            Function to take any manor of path and resolve it and retrun the coreected path.
            We don't care if it exist or not, we just one to normalize it.
            </summary>
            <param name="filepath">File path to be checked</param>
            <param name="with_root">Should the file path start fromt he root (default false)</param>
            <returns>String - Return the normalized string</returns>
        </member>
        <member name="M:stellar.Services.file_handler.write_to_file(System.String,System.String)">
            <summary>
            Function to write to file with checks making sure to log creation
            </summary>
            <param name="file">File with path name to write to</param>
            <param name="content">String to write to file</param>
            <returns>Return Boolean - did the file get writen?</returns>
        </member>
        <member name="M:stellar.Services.file_handler.write_to_file(System.String,System.String,System.Boolean)">
            <summary>
            Function to write to file with checks making sure to log creation
            </summary>
            <param name="file">File with path name to write to</param>
            <param name="content">String to write to file</param>
            <param name="append">should we append or overwirte. (false)</param>
            <returns>Return Boolean - did the file get writen?</returns>
        </member>
        <member name="M:stellar.Services.file_handler.read_from_file(System.String)">
            <summary>
            Function output a string from file
            </summary>
            <param name="file">File name to read from</param>
            <returns>Return String - a string of the file contents.  If the file doesn't exists it retruns empty</returns>
        </member>
        <member name="M:stellar.Services.file_handler.read_from_file(System.String,System.Int32,System.Int32)">
            <summary>
            Function output a string from file
            </summary>
            <param name="file">File name to read from</param>
            <param name="limit">If the file is locked, give it a timed amount to try again</param>
            <param name="recursion"></param>
            <returns>Return String - a string of the file contents.  If the file doesn't exists it retruns empty</returns>
        </member>
        <member name="M:stellar.Services.file_handler.ByteArrayToFile(System.String,System.Byte[])">
            <summary>
            Function to save byte array to a file
            </summary>
            <param name="_FileName">File name to save byte array</param>
            <param name="_ByteArray">Byte array to save to external file</param>
            <returns>Return true if byte array save successfully, if not return false</returns>
        </member>
        <member name="T:stellar.Services.objectService">
            <summary>
            This is where we get methods to handle and access objects to reading the 
            complied parts of the app it's self.
            </summary>
        </member>
        <member name="M:stellar.Services.objectService.get_service_methods(System.String)">
            <summary>
            This will list out all the methods that are publicly avaible
            </summary>
            <param name="Service">The Serivce we wish to look into</param>
            <returns>List of hashtables - the hashtable is the method name and it's value is it's parameter count</returns>
        </member>
        <member name="M:stellar.Services.objectService.get_method_summary(System.String,System.String,System.Int32)">
            <summary>
            This will get the summary of the method matched by it's paramerter count
            </summary>
            <param name="Service">The Serivce we wish to look into</param>
            <param name="method">The name of the method we want</param>
            <param name="selected">The number of paramerters it should have to avoid an ambiguous method exception</param>
            <returns>String - The summary of the method we looked up.  Return with empty string if no match is found</returns>
        </member>
        <member name="M:stellar.Services.objectService.get_method_parameters(System.String,System.String,System.Int32)">
            <summary>
            This will get the parameters of the method matched by it's paramerter count
            </summary>
            <param name="Service">The Serivce we wish to look into</param>
            <param name="method">The name of the method we want</param>
            <param name="selected">The number of paramerters it should have to avoid an ambiguous method exception</param>
            <returns>Hashtable - The parameters of the method we looked up.</returns>
        </member>
        <member name="M:stellar.Services.objectService.get_method_return(System.String,System.String,System.Int32)">
            <summary>
            This will get the return of the method matched by it's paramerter count
            </summary>
            <param name="Service">The Serivce we wish to look into</param>
            <param name="method">The name of the method we want</param>
            <param name="selected">The number of paramerters it should have to avoid an ambiguous method exception</param>
            <returns>String - The return of the method we looked up.  Return with empty string if no match is found</returns>
        </member>
        <member name="M:stellar.Services.objectService.explode(System.String)">
            <summary>
            Create an array form a string
            </summary>
            <param name="str">The string to break apart.</param>
            <returns>String[] - an array of strings</returns>
        </member>
        <member name="M:stellar.Services.objectService.explode(System.String,System.String)">
            <summary>
            Create an array form a string
            </summary>
            <param name="str">The string to break apart.</param>
            <param name="split_by">What to brake the string apart by.</param>
            <returns>String[] - an array of strings</returns>
        </member>
        <member name="M:stellar.Services.objectService.pull_params(System.String,System.Collections.Hashtable)">
            <summary>
            Create a Hashtable from a string in normal name value pair lexicons
            </summary>
            <param name="paramList">The string to pull name value pairs out of</param>
            <param name="paramtable">The hashtable to marge into</param>
            <returns>Hashtable of the name value pairs</returns>
            <remarks>NOTE WE SHOULD CHANGE THIS TO NOT FORCE A MARGE</remarks>
        </member>
        <member name="M:stellar.Services.objectService.marge_params(System.Collections.IDictionary,System.Collections.Hashtable)">
            <summary>
            Take the monorail PropertyBag and pushes it to a Hashtable
            </summary>
            <remarks>DEPECATITED</remarks>
        </member>
        <member name="M:stellar.Services.objectService.merge_tables(System.Collections.Hashtable,System.Collections.Hashtable)">
            <summary>
            Marge to Hashtables but don't overwrite if a key is there
            </summary>
            <param name="newitems">The Hashtable of we are marging into</param>
            <param name="paramtable">The Hashtable of key,values we wish to marge</param>
        </member>
        <member name="M:stellar.Services.objectService.merge_tables(System.Collections.Hashtable,System.Collections.Hashtable,System.Boolean)">
            <summary>
            Marge to Hashtables and overwrite if a key is there if flaged to do so
            </summary>
            <param name="newitems">The Hashtable of we are marging into</param>
            <param name="paramtable">The Hashtable of key,values we wish to marge</param>
            <param name="overwrite">To overwrite or not to</param>
        </member>
        <member name="M:stellar.Services.objectService.merge_lists(System.Object,System.Object)">
            <summary>
            Marge to Hashtables and overwrite if a key is there if flaged to do so
            </summary>
            <param name="primary_list">The List of we are marging into</param>
            <param name="list">The List of key,values we wish to marge</param>
            <remarks>NEED FIX</remarks>
        </member>
        <member name="M:stellar.Services.objectService.params_to_PropertyBag(System.Collections.IDictionary,System.Collections.Hashtable)">
            <summary>
            Copy a Hashtable to the monorail PropertyBag 
            </summary>
            <param name="PropertyBag">The bag to write to</param>
            <param name="paramtable">The table to copy</param>
            <returns>IDictionary (PropertyBag) - The monorail PropertyBag we marged into.</returns>
        </member>
        <member name="M:stellar.Services.objectService.PropertyBag_to_params(System.Collections.IDictionary,System.Collections.Hashtable)">
            <summary>
            Copy the monorail PropertyBag to a Hashtable
            </summary>
            <param name="PropertyBag">The bag to use</param>
            <param name="paramtable">The table to write to</param>
            <returns>Hashtable - The table we marged into.</returns>
        </member>
        <member name="T:stellar.Services.XmlDocumentationExtensions">
            <summary>
            Provides extension methods for reading XML comments from reflected members.
            </summary>
        </member>
        <member name="M:stellar.Services.XmlDocumentationExtensions.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:stellar.Services.XmlDocumentationExtensions.GetMemberElementName(System.Reflection.MemberInfo)">
            <summary>
            Returns the expected name for a member element in the XML documentation file.
            </summary>
            <param name="member">The reflected member.</param>
            <returns>The name of the member element.</returns>
        </member>
        <member name="M:stellar.Services.XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.MemberInfo)">
            <summary>
            Returns the XML documentation (summary tag) for the specified member.
            </summary>
            <param name="member">The reflected member.</param>
            <returns>The contents of the summary tag for the member.</returns>
        </member>
        <member name="M:stellar.Services.XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.MemberInfo,System.String)">
            <summary>
            Returns the XML documentation (summary tag) for the specified member.
            </summary>
            <param name="member">The reflected member.</param>
            <param name="pathToXmlFile">Path to the XML documentation file.</param>
            <returns>The contents of the summary tag for the member.</returns>
        </member>
        <member name="M:stellar.Services.XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.MemberInfo,System.Xml.Linq.XDocument)">
            <summary>
            Returns the XML documentation (summary tag) for the specified member.
            </summary>
            <param name="member">The reflected member.</param>
            <param name="xml">XML documentation.</param>
            <returns>The contents of the summary tag for the member.</returns>
        </member>
        <member name="M:stellar.Services.XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.ParameterInfo)">
            <summary>
            Returns the XML documentation (returns/param tag) for the specified parameter.
            </summary>
            <param name="parameter">The reflected parameter (or return value).</param>
            <returns>The contents of the returns/param tag for the parameter.</returns>
        </member>
        <member name="M:stellar.Services.XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.ParameterInfo,System.String)">
            <summary>
            Returns the XML documentation (returns/param tag) for the specified parameter.
            </summary>
            <param name="parameter">The reflected parameter (or return value).</param>
            <param name="pathToXmlFile">Path to the XML documentation file.</param>
            <returns>The contents of the returns/param tag for the parameter.</returns>
        </member>
        <member name="M:stellar.Services.XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.ParameterInfo,System.Xml.Linq.XDocument)">
            <summary>
            Returns the XML documentation (returns/param tag) for the specified parameter.
            </summary>
            <param name="parameter">The reflected parameter (or return value).</param>
            <param name="xml">XML documentation.</param>
            <returns>The contents of the returns/param tag for the parameter.</returns>
        </member>
        <member name="M:stellar.Services.TypeExtensions.GetTypeFromSimpleName(System.String)">
            <summary>
            Type t;
            
            t = TypeExtensions.GetTypeFromSimpleName("string");
            t = TypeExtensions.GetTypeFromSimpleName("int[]");
            t = TypeExtensions.GetTypeFromSimpleName("decimal?");
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="T:stellar.Services.file_info">
            <summary>
            This is for returning information on a file.  Get path info to light searching
            </summary>
        </member>
        <member name="M:stellar.Services.file_info.root_path">
            <summary>
            Function output a string of the root path
            </summary>
            <returns>Return String - a string of the root path of the applaction root</returns>
        </member>
        <member name="M:stellar.Services.file_info.site_path">
            <summary>
            Function output a string of the root path
            <param name="site_alias">String - alias of the requested site</param>
            </summary>
            <returns>Return String - a string of the root path of the site requested</returns>
        </member>
        <member name="M:stellar.Services.file_info.is_relative_path(System.String)">
            <summary>
            Is the path we are looking at a relative path
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:stellar.Services.file_info.is_media_file(System.String)">
            <summary>
            A simple check to see if it's a known media file
            </summary>
            <param name="extension">the file extension</param>
            <returns></returns>
        </member>
        <member name="M:stellar.Services.file_info.dir_exists(System.String)">
            <summary>
            Function to take any manor of path and resolve if the Directory is really there
            </summary>
            <param name="sDirName">Directory path to be checked</param>
            <returns>Boolean - Return true if found</returns>
        </member>
        <member name="M:stellar.Services.file_info.file_exists(System.String)">
            <summary>
            Function to take any manor of path and resolve if the file is really there
            </summary>
            <param name="file">File path to be checked</param>
            <returns>Boolean - Return true if found</returns>
        </member>
        <member name="M:stellar.Services.file_info.DirSearch(System.String)">
            <summary>
            Function to loop thru the directories and complie a list of files
            </summary>
            <param name="sDir">Directory path to be checked</param>
            <param name="splitOn">Return only the back half of the path (make relative)</param>
            <param name="ext">Find only this extension</param>
            <param name="start">Start Depth of recursion return</param>
            <param name="end">Stop Depth of recursion</param>
            <param name="recursion">Current depth of recursion no start</param>
            <returns>List - Return list of paths found</returns>
        </member>
        <member name="M:stellar.Services.file_info.is_locked(System.String)">
            <summary>
            Check if the file is locked
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="T:stellar.Services.file_routines">
            <summary>
            These are methods of file crud that will keep us from error when possible.  Mostly to copy.
            </summary>
        </member>
        <member name="M:stellar.Services.watermaking.watermaker_img(System.Drawing.Image,System.Int32,System.String)">
            <summary>
            This does images
            </summary>
            <param name="imgPhoto"></param>
            <param name="img_id"></param>
            <param name="mark"></param>
            <returns></returns>
        </member>
        <member name="T:stellar.file_mime">
            <summary>
            Start with a quick lookup in a hardcoded list of known mime
            and if it is not found then a there is a chance it's something 
            custom that would have had to be loaded and so look to the system for help
            </summary>
        </member>
        <member name="M:stellar.Services.postingService.get_post_types">
            <summary>
            Get a list of post_type objects
            </summary>
            <returns></returns>
        </member>
        <member name="M:stellar.Services.postingService.get_posting_by_file(System.String,System.Boolean)">
            <summary>
            This will look up a posting by the static file.   It will look from the back of the path so foo.css 
            would pull up a posting that had it's static_file matching the fragment.  For example, we have a 
            posting that has a static_file property of /Content/css/frontend/foo.css and we looked it up by
            foo.css.  But if we had two postings with teh same file name then looking it up would only return the 
            fist matched posting.  It is suggested that you use as much of the path as you can to avoid this.  In the case
            just outlined, if the first posting had static_file property of /Content/css/frontend/foo.css and the second 
            posting had static_file property of /Content/css/admin/foo.css then the filepath argument for this s function
            should be /admin/foo.css for ensurence that the right one was returned.
            </summary>
            <param name="filepath">This is the fragment to look up for.</param>
            <param name="usedev"></param>
            <returns></returns>
        </member>
        <member name="M:stellar.Services.postingService.create_post_file_info(stellar.Models.posting)">
            <summary>
            This is to make the meta string block for a non-meta files.
            </summary>
            <param name="post"></param>
            <returns></returns>
        </member>
        <member name="M:stellar.Services.postingService.strip_post_file_info(System.String)">
            <summary>
            Strip the meta block for a non-meta files.
            </summary>
            <param name="file_content"></param>
            <returns></returns>
        </member>
        <member name="M:stellar.Services.postingService.get_post_file_info(System.String)">
            <summary>
            This is for non-meta files.
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:stellar.Services.postingService.create_post_from_file(System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,stellar.Models.appuser,System.Boolean)">
            <summary>
            This take a file, regardless of if there is a post already for this file, 
            and ingests it to the database as a posting.
            </summary>
            <param name="file">What file to use</param>
            <param name="name">Basic post data.</param>
            <param name="theme">What theme should it respond to?</param>
            <param name="posting_type">What posting type should be used</param>
            <param name="version">The starting version</param>
            <param name="revision">The starting revision</param>
            <param name="user">the user the post belongs to</param>
            <param name="loads_file">Should the post use the file or the database.</param>
            <returns></returns>
            <remarks>A new pst from file may only be created from a file with in the working folder or it'll fail to make the post.</remarks>
        </member>
        <member name="T:stellar.Services.versionService">
             <summary>
              This will be the handler for versioning.  We will try to infer version information from 4 spots
              1.) DB 2.)by location 3.)in filename 4.) in file metadata
            
             What is the process path:
             - on update, is it an autosave or apply?
             - if yes then don't make a new reversion post, just save the working post
             - if(it's save/subbmit) make revision post and save the working post
             - if(it's publish) make revision, save the working post, copy working to published post
             
             For redunency initally the revision is copy of the saved working post.  Initally the published post
             is copy of the working post.  A working copy is just a data storage area the user directly accesses.
             We don't want to every let the user touch the revisions or published files.  Reverting back to a revision
             makes a new revision and copies it to the working post.
             </summary>
        </member>
        <member name="M:stellar.Services.versionService.make_post_revision(stellar.Models.posting)">
            <summary>
            This function will take a working copy, add the version it to both the file and 
            the object and move the file to the revision folder for safe keeping.  
            </summary>
            <param name="working_copy"></param>
            <returns></returns>
            <remarks> DB >> FILE    (THIS MAY ONLY COME FROM THE WORKING POSTING)</remarks>
        </member>
        <member name="M:stellar.Services.versionService.publish_post(stellar.Models.posting)">
            <summary>
            The post partent will be updated with the latest content and setting.  
            Also this is push a file copy to the published folder as well as make the copies.
            </summary>
            <param name="working_copy"></param>
            <returns></returns>
        </member>
        <member name="M:stellar.Services.versionService.make_post_publised_version(stellar.Models.posting)">
            <summary>
            The post partent will be updated with the latest content and setting.  
            Also this is push a file copy to the published folder as well as make the copies.
            </summary>
            <param name="working_copy"></param>
            <param name="version"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:stellar.Services.formactionService.form_entry_match(stellar.Models.posting,System.String)" -->
        <member name="M:stellar.Services.htmlService.has_external_link(System.String)">
            <summary>
            Is there an external link or url in the text?
            </summary>
            <param name="html">String - html string to check against</param>
            <returns>Boolean - Return true if match</returns>
        </member>
        <member name="M:stellar.Services.htmlService.tabs(System.Int32)">
            <summary>
            add tabs where tabs can't be inserted var the UI
            </summary>
            <param name="n">Int - number of tabs to return</param>
            <returns>String - string of tab chars</returns>
        </member>
        <member name="M:stellar.Services.htmlService.truncate(System.String,System.Int32)">
            <summary>
            add tabs where tabs can't be inserted var the UI
            </summary>
            <param name="source">String - String of html to work with</param>
            <param name="length">Int - number of tabs to return</param>
            <param name="wrap">String - Text that must have {$i} in it which the source will replace</param>
            <param name="more_txt">String - a string to append to the back of the source string (outside of wrap)</param>
            <returns>String - Return formated and truncated</returns>
            @TODO use template for this and from site level options
        </member>
        <member name="M:stellar.Services.htmlService.StripTagsCharArray(System.String)">
            <summary>
            Remove HTML tags from string using char array.
            </summary>
        </member>
        <member name="M:stellar.Services.htmlService.AbsolutePath(System.String,System.String,System.String)">
            <summary>
            Fixes a path. Makes sure it is a fully functional absolute url.
            </summary>
            <param name="originatingUrl">The url that the link was found in.</param>
            <param name="link">The link to be fixed up.</param>
            <returns>A fixed url that is fit to be fetched.</returns>
        </member>
        <member name="M:stellar.Services.htmlService.ResolveRelativePaths(System.String,System.String)">
            <summary>
            Needed a method to turn a relative path into an absolute path. And this seems to work.
            </summary>
            <param name="relativeUrl">The relative url.</param>
            <param name="originatingUrl">The url that contained the relative url.</param>
            <returns>A url that was relative but is now absolute.</returns>
        </member>
        <member name="M:stellar.Services.httpService.getbaseUrl(System.String)">
            <summary>
            Gets the base url from the url passed in.
            </summary>
            <param name="url">String - url string to pull from</param>
            <returns>String - Return the domain.tld of a uri</returns>
        </member>
        <member name="M:stellar.Services.httpService.getCurrentBaseURL">
            <summary>
            Gets the base url from the current url location.
            </summary>
            <returns>String - Return the domain.tld of a uri</returns>
        </member>
        <member name="M:stellar.Services.httpService.getRootUrl">
            <summary>
            Gets the base url from the current url location.
            </summary>
            <returns>String - Return the domain.tld of a uri</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:stellar.Services.httpService.getUrlParmas_obj" -->
        <member name="M:stellar.Services.httpService.is_url_online(System.String)">
            <summary>
            Check to see if the url is there
            </summary>
            <param name="url">Target url, fire</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:stellar.Services.httpService.getPostParmas_obj" -->
        <member name="M:stellar.Services.httpService.GetPageAsString(System.Uri)">
            <summary>
            Get a string of the response from a url.
            </summary>
            <param name="address">The address you wish to capture</param>
            <returns>String - the content of a url without the javascript and all urls normalized to be absolute to the url the content come from</returns>
        </member>
        <member name="M:stellar.Services.httpService.CopyStream(System.IO.Stream,System.IO.Stream)">
            <summary>
            Copies a stream into a new steam for manipulation
            </summary>
            <param name="input">The Stream to copy</param>
            <param name="output">The Stream to recive the copy</param>
            <returns>void - This will only copy a stream to another stream already created</returns>
        </member>
        <member name="M:stellar.Services.httpService.DownloadImage(System.String)">
            <summary>
            Copies an image file from a url to a Image type object for manipulation
            </summary>
            <param name="_URL">The url of the image you wish to capture</param>
            <returns>Image - This will creat a Object typed as Image for manipulation</returns>
        </member>
        <member name="M:stellar.Services.httpService.HttpUploadFile(System.String,System.String,System.String,System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            POST a file to a url with optional params
            </summary>
            <param name="url">The url of where the file you wish to upload is to go</param>
            <param name="file">The file path of the file you with to POST</param>
            <param name="paramName">The parameter name of the file</param>
            <param name="contentType">the content type of the file in "text/plain" for a foo.txt file</param>
            <param name="nvc">Additional POST Data</param>
            <returns>String - the respones of the file post to the url</returns>
        </member>
    </members>
</doc>
